# $Id$ #

Oinkmaster FAQ
--------------

Q1:  I want to download the rules archive using the program XXXXX, which 
     I can't do with Oinkmaster. What do I do?
Q2:  Can Oinkmaster be useful for distributing rules locally to my 
     sensors?
Q3:  Can Oinkmaster be useful for distributing my homemade rules to my 
     sensors?
Q4:  In which order will 'modifysid'/'disablesid'/'enablesid' be 
     processed?
Q5:  How can the 'include' statement in oinkmaster.conf be useful?
Q6:  Can Oinkmaster restart Snort after an update?
Q7:  Can I tell Oinkmaster to not touch certain SIDs in sid-msg.map so 
     the entries I add for my local rules don't get deleted?
Q8:  I want to copy the rules archive from a remote host to the sensor 
     via scp (i.e. run "oinkmaster -u scp://user@foohost:/foo/rules.tar.gz 
     ..." on the sensor to pull the rules from foohost) without having to 
     supply a password or passphrase, but I also don't want to give the 
     sensors full access to that host. Can this be done?
Q9:  How do I setup proxy configuration?
Q10: Can Oinkmaster be used to update rules from www.whitehats.com?
Q11: Will Oinkmaster fail when new keywords are introduced in the rules?
Q12: What license are the official Snort rules reeased under, and
     can I modify them without violating it?



Q1:  I want to download the rules archive using the program XXXXX, which 
     I can't do with Oinkmaster. What do I do?

A1:  Use whatever program you want to download the rules archive to the 
     local filesystem first, and then run Oinkmaster with
     -u file://<filename>.



Q2:  Can Oinkmaster be useful for distributing rules locally to my 
     sensors?

A2:  Yes, there are several situations where Oinkmaster can be handy when
     dealing with local rules management. If you have only a few sensors,
     you can simply run Oinkmaster in a traditional way to update the 
     rules from the Internet on all of them. However, if the sensors have 
     no way to talk to the outside, and/or you have many sensors you want 
     to control in a convenient way, you'll want to consider another 
     solution.

     A common way to solve this is to have a "master" host which downloads 
     the rules using Oinkmaster and does some global modifications to 
     them. With some simple scripting, it can then push the rules archive 
     to each sensor which runs Oinkmaster on it. You can also have each 
     sensor run Oinkmaster and pull the rules archive from the master, for 
     example using -u scp://... and point to the master. Each sensor can 
     have it's own oinkmaster.conf to fine-tune the rules (even override 
     global settings done by the master).

     An example step-by-step list how this could be done:

     1) foohost, the master, uses Oinkmaster in a traditional way with 
        its own oinkmaster.conf to download the rules into some local 
        directory. Rules that you modify here will become modified on ALL 
        sensors by default. This is a convenient way to disable rules that 
        you don't want to use on any sensors instead of having to disable 
        them on each sensor, for example. If you don't want any global 
        preprocessing of the rules, you could just use a simple wget of 
        the archive on this host (or run Oinkmaster with a NOOP config).

     2) Create a script that re-creates the rules tarball from the rules
        just downloaded. You could then either push this new archive to 
        all the sensors or have each sensor pull the tarball from foohost 
        using '-u scp://user@foohost:/...'. If your sensors does not have 
        a way to talk to other hosts at all (like when only using 
        receive-only cables), the rules archive will obviously have to be 
        distributed manually using a removable media like a USB memory 
        stick or something. If you pushed the archive to the sensors, they 
        should run Oinkmaster with '-u file:///...' and point to this 
        file. In each local oinkmaster.conf, you can fine-tune the 
        rules to fit this particular sensor.



Q3:  Can Oinkmaster be useful for distributing my homemade rules to my 
     sensors?

A3:  Yes! This can be done almost exactly like in the example above.
     The main difference is that in step 1, you don't download from the
     Internet but rather point to a rules tarball created from a local
     directory (perhaps checked out from a cvs repository) containing 
     your homemade rules. 

     There are a few scripts in Oinkmaster's contrib/ directory (that all 
     handle multi-line rules) that may be useful in this case. For 
     example, addsid.pl will parse all your rules and add the next 
     available SID to rules that don't have any. This may be useful to run 
     before creating the rules tarball. So when adding new homemade rules 
     on the master (and you only have to add them there since they will be 
     distributed to all your sensors automatically), just leave out the 
     SID and it will be filled in for you automatically. You can also use 
     contrib/create-sidmap.pl to create a new sid-msg.map from your rules.



Q4:  In which order will 'modifysid'/'disablesid'/'enablesid' be processed?

A4:  All the 'modifysid' will be processed first, then 'disablesid' and last
     'enablesid'. The order they appear in oinkmaster.conf does not matter.
     So if you use both "enablesid 1" and "disablesid 1" in
     oinkmaster.conf (in any order), SID 1 will first be disabled and then
     enabled. So if SID 1 was enabled by default in the downloaded rules
     archive, this is a NOOP. Disabling a disabled rule is also a NOOP, as
     is enabling an enabled rule.



Q5:  How can the 'include' statement in oinkmaster.conf be useful?

A5:  There are many situations where this is useful, but perhaps the most
     common usage is to be able to use one global and one sensor-specific
     configuration file. You would usually want to make sure to include 
     the sensor-specific file last since possible values that are 
     redefined overrides the previous ones. Remember that you can also 
     use multiple "-C" arguments when starting Oinkmaster to make it load 
     multiple configuration files. They will be loaded in the order of
     appearance on the command line.



Q6:  Can Oinkmaster restart Snort after an update?

A6:  No. This functionality does not belong in Oinkmaster since almost 
     everyone has their own way of restarting Snort. Automatic restart of 
     Snort after an update is usually no good idea either. See the README
     for more information. If you really want to do an automatic restart, 
     just write a little wrapper that does what you want, and remember to 
     run snort -T first and refuse to restart if the test was not 
     successful.



Q7:  Can I tell Oinkmaster to not touch certain SIDs in sid-msg.map so 
     the entries I add for my local rules don't get deleted?

A7:  No. What you may want to consider instead is to use a separate
     sid-msg.map for your local rules (and not touch the map for the
     official rules), and then join the two before feeding it to 
     Barnyard/whatever. Or, what is probably even better, is to generate 
     the sid-msg.map automatically yourself after each update. There is 
     one script in Snort's contrib directory that does this, and there is 
     also one that comes with Oinkmaster (contrib/create-sidmap.pl). The 
     latter handles multi-line rules and can also take an arbitrary number 
     of rules directories as argument.



Q8:  I want to copy the rules archive from a remote host to the sensor 
     via scp (i.e. run "oinkmaster -u scp://user@foohost:/foo/rules.tar.gz 
     ..." on the sensor to pull the rules from foohost) without having to 
     supply a password or passphrase, but I also don't want to give the 
     sensors full access to foohost. Can this be done?

A8:  Yes. You should really rely on the OpenSSH documentation on how to 
     do this as this is well documented there, but an attempt at 
     explaining how it could be done follows. The instructions assumes 
     OpenSSH on both client and server. 

     If you want to automate the process of just copying a file with scp, 
     you should never have to give one host full access to the other. One 
     solution is to generate a key pair where the private key has no 
     passphrase and the public key has restrictions to only allow the 
     copy. (If you don't plan on running Oinkmaster unattended, it's of 
     course recommended to use a passphrase anyway, even though the public 
     key should still contain as many restrictions as possible.)

     First, generate the key pair on the sensor (i.e. the host that is
     going to run Oinkmaster, not the master host that keeps the 
     archive):

     ssh-keygen -t rsa -C 'oinkmaster copy' -N '' -f oinkmaster_scp

     This will give you two files in the current directory, 
     oinkmaster_scp (private key) and oinkmaster_scp.pub (public key). The 
     public key must now be edited to add some restrictions to it.
     Details about how to add restrictions to a host is described in the
     OpenSSH manual. Perhaps the most important restriction in this case 
     is the command="command". You should also use as many other 
     restrictions as possible, such as from="pattern-list" to only allow 
     the sensor(s), no-pty to prevent pty allocation and also turn off all 
     types of forwarding. You will see that the public key begins with 
     something like "ssh-rsa AAAA...". To only add the command 
     restriction, modify the key to say something like:

     command="scp -f /etc/snort/snortrules.tar.gz" ssh-rsa AAAA...

     This assumes that the tarball will be found as 
     /etc/snort/snortrules.tar.gz on the master host, but change it to the 
     location where you store the tarball there. When you're done editing 
     oinkmaster_scp.pub, append the contents of it to the master host's
     ~/.ssh/authorized_keys for the user that will be used to perform the 
     copy. This should not be a privileged user, the only requirement is 
     that this user has read access to the rules archive.

     Now make sure that you put the private key (oinkmaster_scp) in a 
     suitable directory on the sensor. Then tell Oinkmaster to use this 
     key by specifying "scp_key = ..." in oinkmaster.conf,
     You could use something like 
     "scp_key = /home/oinkmaster/.ssh/oinkmaster_scp".
     Or you can use ~/.ssh/config to specify the key as described in the 
     OpenSSH manual. Then you should be able to start Oinkmaster with 
     something like:

     oinkmaster.pl -u scp://user@foohost:/etc/snort/snortrules.tar.gz -o rules

     It will copy the archive without asking for a password/passphrase.
     You should see something like:

     ...
     Copying rules archive from oink@somehost:/etc/snort/snortrules.tar.gz using scp:
     snortrules.tar.gz                                 100%  110KB   0.0KB/s   00:00
     Archive successfully downloaded, unpacking... done.
     ...

     If you start Oinkmaster in verbose mode (-v), scp will be run in
     verbose mode as well.



Q9:  How do I setup proxy configuration?

A9:  If you download the snort rules archive from a web site (e.g. 
     www.snort.org) and you are a behind an http proxy, you need to tell 
     Oinkmaster to use that proxy or the download will fail. How you do 
     that depends if you use wget (i.e. use use_external_bins=1 in 
     oinkmaster.conf) or libwww-perl (use_external_bins=0). You can read 
     their man pages for complete instructions configuration ("man wget" 
     or "man LWP::UserAgent").

     Quick instructions for the impatient:

     For wget, you can either edit the wget configuration file (usually
     /etc/wgetrc for global settings and ~/wgetrc for user settings) and 
     set the http_proxy option. For example: 
     "http_proxy = http://your_proxy_host:3128:/"
     (or http_proxy = http://user:password@your_proxy_host:3128/ if you 
     are required to authenticate to the proxy). You can also set the 
     http_proxy environment variable. If you want your proxy server not to 
     return the file in it's cache but rather get it from the web server 
     again, add "header = Pragma: no-cache" to your wget configuration 
     file.

     For libwww-perl, set the http_proxy environment variable as 
     described above (i.e. to "http://your_proxy_host:3128:/" or 
     "http://user:password@your_proxy_host:3128/").



Q10: Can Oinkmaster be used to update rules from www.whitehats.com?

A10: No, the Snort rules on www.whitehats.com has currently not been 
     maintained for a long long time and should not be used (although the 
     arachNIDS database is still a good source of information for older 
     rules). Use the rules on www.snort.org instead.

     (And for Oinkmaster to work, the rules package must be a gzipped 
     tar file that contains a directory called "rules", which holds
     all the rules files.)



Q11: Will Oinkmaster fail when new keywords are introduced in the rules?

A11: No. (Not unless there is a bug in Oinkmaster anyway.) Oinkmaster was 
     designed to be stupid and not try to understand every single part of 
     the rules. Basically, for a rule to be successfully identified by 
     Oinkmaster, it must start with one of the keywords in 'rule_actions' 
     specified in oinkmaster.conf. It must also contain 
     'msg: "some message";' and 'sid: <sid>;'. Some basic syntax checks 
     are also performed, but the rest is ignored.

     If a rule can not be successfully parsed for some reason, it will 
     simply be regarded as a non-rule line (or multiple non-rule lines if 
     it's a multi-line rule). Since non-rule lines are also compared and 
     updated by Oinkmaster, things will work as usual anyway except that
     actions such as disablesid on that rule will have no effect.



Q12: What license are the official Snort rules reeased under, and
     can I modify them without violating it?

A12: The Snort people have answered this a few times on the Snort lists,
     but here is a small summary. The official Snort signatures are
     part of Snort and are therefore also released under GPL.
     You can modify them locally as much as you want, but if
     distributing them, they need to be GPL-licensed as well.
